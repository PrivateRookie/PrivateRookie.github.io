<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust代码风格tips - 夜雨秋灯录</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../导言.html">导言</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../文章.html"><strong aria-hidden="true">1.</strong> 文章</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../posts/2018-06-24-openstack创建虚拟机源码阅读.html"><strong aria-hidden="true">1.1.</strong> openstack创建虚拟机源码阅读</a></li><li class="chapter-item "><a href="../posts/2018-06-27-Bottle-框架中装饰器类和描述符应用.html"><strong aria-hidden="true">1.2.</strong> Bottle-框架中装饰器类和描述符应用</a></li><li class="chapter-item "><a href="../posts/2019-04-17-使用devpi搭建本地源.html"><strong aria-hidden="true">1.3.</strong> 使用devpi搭建本地源</a></li><li class="chapter-item "><a href="../posts/2019-04-20-Python展开嵌套序列.html"><strong aria-hidden="true">1.4.</strong> Python展开嵌套序列</a></li><li class="chapter-item "><a href="../posts/2019-04-20-pipenv-使用简介.html"><strong aria-hidden="true">1.5.</strong> pipenv-使用简介</a></li><li class="chapter-item "><a href="../posts/2019-04-22-深度系统rust开发环境搭建.html"><strong aria-hidden="true">1.6.</strong> 深度系统rust开发环境搭建</a></li><li class="chapter-item "><a href="../posts/2019-05-01-miniserve-miniserve简单美观的文件服务器.html"><strong aria-hidden="true">1.7.</strong> miniserve-miniserve简单美观的文件服务器</a></li><li class="chapter-item "><a href="../posts/2019-05-05-magnum-stein-release-new-features.html"><strong aria-hidden="true">1.8.</strong> magnum-stein-release-new-features</a></li><li class="chapter-item "><a href="../posts/2019-05-12-rust-rc.html"><strong aria-hidden="true">1.9.</strong> rust-rc</a></li><li class="chapter-item "><a href="../posts/2019-05-20-Python-Rust-迭代器类比.html"><strong aria-hidden="true">1.10.</strong> Python-Rust-迭代器类比</a></li><li class="chapter-item "><a href="../posts/2019-06-28-搭建etcd服务发现服务.html"><strong aria-hidden="true">1.11.</strong> 搭建etcd服务发现服务</a></li><li class="chapter-item "><a href="../posts/2019-07-03-OpenStack允许root用户使用ssh-key登录.html"><strong aria-hidden="true">1.12.</strong> OpenStack允许root用户使用ssh-key登录</a></li><li class="chapter-item "><a href="../posts/2019-07-06-requirements.txt文件指定依赖.html"><strong aria-hidden="true">1.13.</strong> requirements.txt文件指定依赖</a></li><li class="chapter-item "><a href="../posts/2019-07-10-我经常使用的Rust小crate.html"><strong aria-hidden="true">1.14.</strong> 我经常使用的Rust小crate</a></li><li class="chapter-item "><a href="../posts/2019-07-14-Rust模块与文件.html"><strong aria-hidden="true">1.15.</strong> Rust模块与文件</a></li><li class="chapter-item "><a href="../posts/2019-07-18-Deepin安装Angular10+.html"><strong aria-hidden="true">1.16.</strong> Deepin安装Angular10+</a></li><li class="chapter-item "><a href="../posts/2019-07-25-使用OSProfiler.html"><strong aria-hidden="true">1.17.</strong> 使用OSProfiler</a></li><li class="chapter-item "><a href="../posts/2019-07-27-windows上使用vscode-remote.html"><strong aria-hidden="true">1.18.</strong> windows上使用vscode-remote</a></li><li class="chapter-item "><a href="../posts/2019-08-04-使用rust-analyzer.html"><strong aria-hidden="true">1.19.</strong> 使用rust-analyzer</a></li><li class="chapter-item "><a href="../posts/2019-08-16-Python-package安装时安装额外文件.html"><strong aria-hidden="true">1.20.</strong> Python-package安装时安装额外文件</a></li><li class="chapter-item "><a href="../posts/2019-08-31-Rust-命令行工具.html"><strong aria-hidden="true">1.21.</strong> Rust-命令行工具</a></li><li class="chapter-item "><a href="../posts/2019-09-27-Fedora-CoreOS-尝鲜.html"><strong aria-hidden="true">1.22.</strong> Fedora-CoreOS-尝鲜</a></li><li class="chapter-item expanded "><a href="../posts/2020-01-31-rust代码风格tips.html" class="active"><strong aria-hidden="true">1.23.</strong> rust代码风格tips</a></li><li class="chapter-item "><a href="../posts/2020-02-03-log4rs-Rust-log库.html"><strong aria-hidden="true">1.24.</strong> log4rs-Rust-log库</a></li><li class="chapter-item "><a href="../posts/2020-02-29-impl-Trait-vs-dyn-Trait.html"><strong aria-hidden="true">1.25.</strong> impl-Trait-vs-dyn-Trait</a></li><li class="chapter-item "><a href="../posts/2020-03-04-nom-cheatsheet.html"><strong aria-hidden="true">1.26.</strong> nom-cheatsheet</a></li><li class="chapter-item "><a href="../posts/2020-03-09-gitlab-runner启动守护进程.html"><strong aria-hidden="true">1.27.</strong> gitlab-runner启动守护进程</a></li><li class="chapter-item "><a href="../posts/2020-03-21-使用nom写parser.html"><strong aria-hidden="true">1.28.</strong> 使用nom写parser</a></li><li class="chapter-item "><a href="../posts/2020-05-10-使用nom写parser.html"><strong aria-hidden="true">1.29.</strong> 使用nom写parser</a></li><li class="chapter-item "><a href="../posts/2020-06-07-使用nom写parser.html"><strong aria-hidden="true">1.30.</strong> 使用nom写parser</a></li><li class="chapter-item "><a href="../posts/2020-06-25-Rust实现的日至收集工具.html"><strong aria-hidden="true">1.31.</strong> Rust实现的日至收集工具</a></li><li class="chapter-item "><a href="../posts/2020-07-19-typing+pyright-更正确的Python代码.html"><strong aria-hidden="true">1.32.</strong> typing+pyright-更正确的Python代码</a></li><li class="chapter-item "><a href="../posts/2020-07-31-boxercrab发布.html"><strong aria-hidden="true">1.33.</strong> boxercrab发布</a></li><li class="chapter-item "><a href="../posts/2020-08-16-使用nom写parser.html"><strong aria-hidden="true">1.34.</strong> 使用nom写parser</a></li><li class="chapter-item "><a href="../posts/2020-08-30-PowerShell配置.html"><strong aria-hidden="true">1.35.</strong> PowerShell配置</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="../笔记.html"><strong aria-hidden="true">2.</strong> 笔记</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../notes/rust/2021-10-31-嵌套解构.html"><strong aria-hidden="true">2.1.</strong> 嵌套解构</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">夜雨秋灯录</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-代码风格-tips"><a class="header" href="#rust-代码风格-tips">Rust 代码风格 Tips</a></h1>
<p>文章绝大部分翻译自<a href="https://github.com/rust-unofficial/patterns">Rust Design Patters</a>, 为了快速简洁, 并没有严格翻译</p>
<hr />
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>Rust 没有类似于 <code>ClassName(*args, **kw_args)</code> 这样的构造函数, 一般约定使用静态的 <code>new</code> 方法创建一个新的“对象”.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    // 构建一个新的空 `Vec&lt;T&gt;`
    // 注意，这是一个静态方法，第一个参数不带有 `self` 或 `Self`
    // 例子中的 new 方法不带任何参数，在有需要时也可以定义用于初始化
    // 的参数
    pub fn new() -&gt; Vec&lt;T&gt; {
        Vec {
            buf: RawVec::new(),
            len: 0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>如果某个结构体的初始化非常复杂，可以考虑使用 <a href="https://github.com/rust-unofficial/patterns/blob/master/patterns/builder.md">builder pattern</a></p>
<h2 id="使用-format-连接字符串"><a class="header" href="#使用-format-连接字符串">使用 <code>format!</code> 连接字符串</a></h2>
<p>处理字符串时可以用 <code>push</code> 和 <code>push_str</code> 方法在一个可变字符串上连接字符串, 或者使用 <code>+</code>.
但在字面字符串和非字面字符串混合的情况下, 使用 <code>format!</code> 会更方便.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn say_hello(name: &amp;str) -&gt; String {
    // 可以先创建一个可变 String, 然后进行
    // push 操作, 但这样操作显然有些麻烦
    // let mut result = &quot;Hello &quot;.to_string();
    // result.push_str(name);
    // result.push('!');
    // result
    format!(&quot;Hello {}!&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>format!</code> 通常是最简洁易读连接字符的方法, 但它有可能不是最有效的方法, 如果某个字符串已经预先分配好且已确定长度时, 通过 <code>push</code> 通常会更高效.</p>
<hr />
<h2 id="使用私有成员实现可扩展性"><a class="header" href="#使用私有成员实现可扩展性">使用私有成员实现可扩展性</a></h2>
<p>使用一个私有成员来保证一个结构体可以在不破坏稳定性的情况下实现扩展.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    pub struct S {
        pub foo: i32,
        bar: i32,
    }
}

fn func(s: a::S) {
    // 因为 bar 是私有成员, 使用如
    // let a::S { foo: _, bar: b } = s;
    // 的结构语法时提示 bar 为私有成员, 因此我们
    // 使用 `..` 来跳过这个私有成员
    let a::S { foo: _, .. } = s;
}
<span class="boring">}
</span></code></pre></pre>
<p>在结构体中添加一个成员通常是向后兼容的. 但这会导致原有模式匹配解构该结构体时抛出没有完全匹配成员的错误.
你可以使用私有成员和在模式匹配使用 <code>..</code> 来跳过一些成员, 即使添加了新的成员, 原有的模式匹配也不会被破坏.</p>
<p>使用这种方法的坏处是需要在结构体中添加不需要的成员, 可以把该成员的类型设置为 <code>()</code> 以避免运行时消耗, 并在成员名前添加 <code>_</code> 避免编译器抛出变量未使用的警告.</p>
<hr />
<h2 id="将集合视作智能指针"><a class="header" href="#将集合视作智能指针">将集合视作智能指针</a></h2>
<p>使用 <code>Deref</code> 特性可以让数据集合被当作智能指针, 提供拥有所有权和借用的数据视图.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec&lt;T&gt; {
    ...
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Vec&lt;T&gt;</code> 拥有一些 <code>T</code> 所有权, 一个 <code>&amp;[T]</code> 切片是一些 <code>T</code> 的借用. 为 <code>Vec</code> 实现 <code>Deref</code> 允许隐式地将 <code>&amp;Vec&lt;T&gt;</code> 转换为 <code>&amp;[T]</code>, 同时也包括了自动解索引的关系. 大多数你希望 <code>Vec</code> 实现的函数实际上是为切片实现的.</p>
<p>一个最常见的例子就是 <code>String</code> 和 <code>&amp;str</code>.</p>
<p>更深入的讨论可以参考<a href="https://github.com/rust-unofficial/patterns/blob/master/idioms/deref.md">原文</a></p>
<hr />
<h2 id="finalisation-in-destructors"><a class="header" href="#finalisation-in-destructors">Finalisation in destructors</a></h2>
<p>Rust 没有 <code>finally</code> 语句块, 即无论函数怎样终止都会执行的语句块, Rust 提供了 <code>Drop</code> 特性来定义对象在析构时需要运行的代码.</p>
<pre><pre class="playground"><code class="language-rust">struct Foo;

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;exit&quot;);
    }
}

fn func() -&gt; Result&lt;(), ()&gt; {
    Ok(())
    // Err(())
}

fn use_foo() -&gt; Result&lt;(), ()&gt; {
    // use_foo 运行完成后将会调用 `Drop`
    // 实现的析构方法, 因此会打印 &quot;exit&quot;
    // 注意: 即使 func 失败了仍然会调用
    // 析构方法
    let _exit = Foo;
    func()?;
    Ok(())
}

fn main() {
    use_foo().unwrap();
}
</code></pre></pre>
<p>值得注意的是 Rust 的 <code>Drop</code> 并不如 <code>finally</code> 那样值得信赖, 因为 <code>Drop</code> 中的代码在某些情况下可能不会运行(如 panic 的线程),
甚至会引发其他问题, 在 <a href="https://rust-unofficial.github.io/too-many-lists/first-drop.html">too many linked list</a> 中的一个例子.</p>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop - doc</a></li>
<li><a href="https://doc.rust-lang.org/book/ch15-03-drop.html">Drop - Rust Book</a></li>
<li><a href="https://github.com/rust-unofficial/patterns/blob/master/patterns/RAII.md">RAII</a></li>
</ul>
<hr />
<h2 id="迭代一个-option"><a class="header" href="#迭代一个-option">迭代一个 <code>Option</code></a></h2>
<p><code>Option</code> 可被是为一个包含0个或1个元素的容器, 且因为其实现了 <code>IntoIterator</code> 特性, 在某些场合, 你可以像使用 <code>Vec</code> 那样使用它.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let turing = Some(&quot;Turing&quot;);
    let mut logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

    logicians.extend(turing);
    // 相当于
    if let Some(turing_inner) = turing {
        logicians.push(turing_inner);
    }
}
</code></pre></pre>
<p>如果你想将一个 <code>Option</code> 链接到一个已有的迭代器, 可以使用 <code>.chain()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let turing = Some(&quot;Turing&quot;);
    let logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

    for logician in logicians.iter().chain(turing.iter()) {
        println!(&quot;{} is a logician&quot;, logician);
    }
}
</code></pre></pre>
<p>如果可以保证 <code>Option</code> 的值总是 <code>Some</code>, 那么可以使用 <code>std::iter::once</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter;

// one is the loneliest number
let mut one = iter::once(1);

assert_eq!(Some(1), one.next());

// just one, that's all we get
assert_eq!(None, one.next());
<span class="boring">}
</span></code></pre></pre>
<p>因为 <code>Option</code> 实现了 <code>IntoIterator</code>, 我们也可以使用 <code>for</code> 来遍历它, 这相当于使用 <code>if let Some(_)</code>, 通常偏向于使用 <code>if let</code>.</p>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/fn.once.html">std::iter::once</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map">Iterator::filter_map</a> 一个快速过滤和映射元素为 <code>Option</code> 或 <code>Result</code> 的迭代器</li>
<li><a href="https://crates.io/crates/ref_slice">ref_slice</a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option<T> - Doc</a></li>
</ul>
<hr />
<h2 id="default-特性"><a class="header" href="#default-特性"><code>Default</code> 特性</a></h2>
<p>正如其名, <code>Default</code> 提供了某个类型或结构体的默认值, 大多数基本类型都实现了 <code>Default</code>, 对于复合类型如 <code>Cow&lt;T&gt;</code>, <code>Box&lt;T&gt;</code> 或 <code>Arc&lt;T&gt;</code>,
如果 <code>T</code> 实现了 <code>Default</code>, 则将会自动实现对应复合类型的 <code>Default</code>.
对于结构体, 如果结构体的每个成员都实现了 <code>Default</code>, 则可以使用 <code>#[derive(Default)]</code> 自动实现.</p>
<p><code>Default</code> 与手动实现的构造方法(通常是 <code>new</code>)不同的是 <code>Default</code> 没有参数而且只能有一个实现, 手动实现的构造方法更加灵活, 可以拥有多个参数和不同实现.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default, Debug)]
struct Foo {
    data: i32,
}

fn main() {
    print!(&quot;Default value of Foo: {:#?}&quot;, Foo::default());
}
</code></pre></pre>
<hr />
<h2 id="将变量传递给闭包"><a class="header" href="#将变量传递给闭包">将变量传递给闭包</a></h2>
<p>闭包默认通过借用捕获环境里的变量, 可以使用 <code>move</code> 强制转移变量所有权. 除此之外还可以使用变量重绑定和子作用域让代码更加清爽.</p>
<p>推荐</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` 所有权移动了
    let num2 = num2.clone();  // `num2` 是克隆的
    let num3 = num3.as_ref();  // `num3` 被借用
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);

let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
	*num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}
</span></code></pre></pre>
<p>推荐写法的好处在于克隆的数据都在一个明显的子作用域中, 更加清晰, 而且可以在使用完成后尽早析构掉, 缺点在于需要额外缩进.</p>
<hr />
<h2 id="使用-memreplace"><a class="header" href="#使用-memreplace">使用 <code>mem::replace</code></a></h2>
<p>假设有如下枚举类型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    A { name: String, x: u8 },
    B { name: String },
}
<span class="boring">}
</span></code></pre></pre>
<p>假设你想在 x = 0 时将 A 转换为 B, 同时保持 B完整. 最直接的想法是使用 <code>clone</code>, 但我们还可以使用 <code>std::mem::replace</code> 减少 clone</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MyEnum {
    A { name: String, x: u8 },
    B { name: String }
}

fn a_to_b(e: &amp;mut MyEnum) {

    // we mutably borrow `e` here. This precludes us from changing it directly
    // as in `*e = ...`, because the borrow checker won't allow it. Therefore
    // the assignment to `e` must be outside the `if let` clause.
    *e = if let MyEnum::A { ref mut name, x: 0 } = *e {

        // this takes out our `name` and put in an empty String instead
        // (note that empty strings don't allocate).
        // Then, construct the new enum variant (which will
        // be assigned to `*e`, because it is the result of the `if let` expression).
        MyEnum::B { name: mem::replace(name, String::new()) }

    // In all other cases, we return immediately, thus skipping the assignment
    } else { return }
}
<span class="boring">}
</span></code></pre></pre>
<p>在处理链表时, 使用 <code>std::mem::replace</code> 可以减少很多繁琐的处理 <code>Option</code> <code>clone</code> 代码. 推荐阅读 <a href="https://rust-unofficial.github.io/too-many-lists/">too many linked list</a></p>
<p>更多介绍请参考<a href="https://github.com/rust-unofficial/patterns/blob/master/idioms/mem-replace.md">原文</a></p>
<hr />
<h2 id="暂时可变性"><a class="header" href="#暂时可变性">暂时可变性</a></h2>
<p>很多情况下我们需要准备和处理某些数据, 之后这些数据就不再被修改, 因此我们希望将该变量由可变转换为不可变.
此时可以再嵌套的语句块中处理数据或者重新定义某个变量.</p>
<p>使用嵌套语句块</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = {
    let mut data = get_vec();
    data.sort();
    data
};
<span class="boring">}
</span></code></pre></pre>
<p>使用变量重绑定</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = get_vec();
data.sort();
let data = data;
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../posts/2019-09-27-Fedora-CoreOS-尝鲜.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../posts/2020-02-03-log4rs-Rust-log库.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../posts/2019-09-27-Fedora-CoreOS-尝鲜.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../posts/2020-02-03-log4rs-Rust-log库.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../lunr.zh.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
